= Simple build environment concept =

The project provides CMake scripts usable in CMakeLists.txt of CPP package.

CPP package can be
  * Library (e.g. [https://code.google.com/p/sbe-documentlibrary DocumentLibrary])
  * Executable (e.g. [https://code.google.com/p/sbe-helloworld HelloWorld])
  * Unit Test Framework (e.g. [https://code.google.com/p/sbe-cpputestlibrary CppUTest])
  * Project - group of Libraries/Executables (e.g. [https://code.google.com/p/sbe-documentationsystem DocumentationSystem])

The scripts support
  * Dependency management
  * Build 
  * Unit testing
  * Continuous Integration
  * Coverity

== Dependency management ==

Each package has file Properties.cmake. The file contains package description (e.g. [https://code.google.com/p/sbe-documentlibrary/source/browse/trunk/Properties.cmake Properties.cmake for DocumentLibrary]).
  * `NAME` - package name
  * `TYPE` - one of _Library, Executable, Unit Test Framework, Project_
  * `VERSION_MAJOR`, `VERSION_MINOR`, `VERSION_PATCH` - should be [http://semver.org semantic version] if applicable. 
  * `DESCRIPTION` - brief description
  * `MAINTAINER` - maintainer email address
  * `DEPENDENCIES` - contains description of each dependency used by package.
  

Each dependency has to have goals `install` and `uninstall`. During installation, dependency has to export targets. The scripts [https://code.google.com/p/cmake-simple-build-environment/source/browse/trunk/scripts/AddInstallTarget.cmake AddInstallTarget.cmake], [https://code.google.com/p/cmake-simple-build-environment/source/browse/trunk/scripts/AddUninstallTarget.cmake AddUninstallTarget.cmake] do this work. The export file is then used in `FIND_PACKAGE` during configuration of dependent package.

Package dependencies are described in variable `DEPENDENCIES`. Each dependency has to start with keyword `DEPENDENCY`. Each dependency can be described with:
  * `URL` - It is mandatory. Repository location of dependency release.
  * `SCM` - It is optional. It is repository type. If no `SCM` keyword is given then default repository `svn` is used. Available types are:
    * svn
  * `EXTERNAL` - It is optional. Meaning of the flag is that dependency marked as external is not included in package goal and will be not automatically updated to its latest releases. When dependency is marked as `EXTERNAL` then all its dependencies are external too. External dependencies have black border and External Stereotype in dependency graph.
    [http://cmake-simple-build-environment.googlecode.com/svn/wiki/images/DependecyGraphExternal.png http://cmake-simple-build-environment.googlecode.com/svn/wiki/images/DependecyGraphExternalSmall.png]
  * `LIBRARIES_TO_LINK` - It is optional. Because some packages doesn't honor [http://www.objectmentor.com/resources/articles/Principles_and_Patterns.pdf the common reuse principle] user can choose via this keyword libraries from package that has to be used in his package.

Example:
<code language="cmake">
set(DEPENDENCIES 
DEPENDENCY 
    URL http://sbe-printerlibrary.googlecode.com/svn/tags/rel_1_0_0 
    SCM svn
    LIBRARIES_TO_LINK PrinterLibrary 
    EXTERNAL 
DEPENDENCY 
    URL http://sbe-documentlibrary.googlecode.com/svn/tags/rel_1_0_0 
)
</code>

=== How it works ===

In your package CMakeLists.txt you have to include [https://code.google.com/p/cmake-simple-build-environment/source/browse/trunk/scripts/DeployDependencies.cmake DeployDependencies.cmake] (e.g. [https://code.google.com/p/sbe-documentlibrary/source/browse/trunk/CMakeLists.txt CMakeLists.txt for DocumentLibrary])

The script performs two steps
  * Exports sources (it uses [https://code.google.com/p/cmake-simple-build-environment/source/browse/trunk/scripts/ExportDependencies.cmake ExportDependencies.cmake])
  * Install sources (it uses [https://code.google.com/p/cmake-simple-build-environment/source/browse/trunk/scripts/InstallDependencies.cmake InstallDependencies.cmake])

During package configuration all dependencies are exported recursively and installed. Installation is necessary during package configuration, because include paths and libraries created by dependency are discovered by `FIND_PACKAGE`.

When dependencies are changed, their sources are deleted and uninstalled.

==== Export Sources ====

The script [https://code.google.com/p/cmake-simple-build-environment/source/browse/trunk/scripts/ExportDependencies.cmake ExportDependencies.cmake] uses `DEPENDENCIES` property defined in CMakeLists.txt to get all dependencies URL in repository.

It exports Properties.cmake recursively for each dependency and generates file `dependencies/info/info.cmake` in package. The file contains all properties from all dependencies.

Once all properties from all dependencies are exported, scripts performs
  # make dependency picture - it uses [http://plantuml.sourceforge.net/ plantuml]
  # check dependencies versions and report error if any - now exact version has to be used
    [http://cmake-simple-build-environment.googlecode.com/svn/wiki/images/DependecyGraphVersionMismatch.png http://cmake-simple-build-environment.googlecode.com/svn/wiki/images/DependecyGraphVersionMismatchSmall.png]
  # check dependencies installation order and report error if any
  # remove unused dependencies
  # exports dependencies sources

Once sources are exported file [http://cmake-simple-build-environment.googlecode.com/svn/wiki/snippets/info.cmake dependencies/info/info.cmake] is created and following variables are set by script [https://code.google.com/p/cmake-simple-build-environment/source/browse/trunk/scripts/ExportDependencies.cmake ExportDependencies.cmake]:
  * `DEP_SOURCES_PATH` - path where all dependencies are exported
  * `DEP_INFO_FILE` - full name of info.cmake file

There are information about each dependency used by package in `DEP_INFO_FILE`. The file can be included into CMakeLists.txt to access dependencies properties. Following variables are available:
  * `OverallDependencies` - it is list of all dependencies identifiers used by package
  * `DEP_INSTALLATION_ORDER` - it is list of dependencies identifiers in order to be installed. It is used by script [https://code.google.com/p/cmake-simple-build-environment/source/browse/trunk/scripts/InstallDependencies.cmake InstallDependencies.cmake]
  * `EXTERNAL_DEPENDENCIES` -  - it is list of dependencies identifiers that are marked as `EXTERNAL` in package
  * For each _dependency_ in `OverallDependencies` list following properties are defined
    * `${`_`dependency`_`}_Name` - name of dependency
    * `${`_`dependency`_`}_Type` - type of dependency
    * `${`_`dependency`_`}_Version` - string version in format major.minor.patch
    * `${`_`dependency`_`}_ScmPath` - URL to repository location
    * `${`_`dependency`_`}_ScmType` - repository type
    * `${`_`dependency`_`}_DependenciesDescription` - it is list same as `DEPENDENCIES` in dependency Properties.cmake file
    * `${`_`dependency`_`}_Dependencies` - it is list of dependencies identifiers
    * `${`_`dependency`_`}_IsExternal` - set to "yes" if dependency is marked as `EXTERNAL`, otherwise it is unset.

All this variables are later used in next configuration steps.

==== Install sources ====

The script [https://code.google.com/p/cmake-simple-build-environment/source/browse/trunk/scripts/InstallDependencies.cmake InstallDependencies.cmake] uses `dependencies/info/info.cmake` prepared by [https://code.google.com/p/cmake-simple-build-environment/source/browse/trunk/scripts/ExportDependencies.cmake ExportDependencies.cmake]. 

The scripts performs:
  # creates build directory `current_project_build_directory/dependencies/build/dependency_name` 
  # configure dependency in created build directory. `CMAKE_TOOLCHAIN_FILE` and `CMAKE_BUILD_TYPE` are propagated to dependency. 
  # install dependency via command `make install`. If coverity is requested, `cov_build` is performed. When dependency is installed, dependent package can use `FIND_PACKAGE` to get information about dependency.

Once sources are installed following variables are set by script [https://code.google.com/p/cmake-simple-build-environment/source/browse/trunk/scripts/InstallDependencies.cmake InstallDependencies.cmake]:
  * `DEP_INSTALL_PATH` - path where all dependencies are installed

== Binary Targets ==

Once dependencies are deployed, dependencies properties can be used to defined own package targets.

Simple Build Environment contains script that do it in following way. 

_ToDo_

If it is not suitable for you can write your own targets and use variables defined during dependencies deployment and Properties.cmake file of your package.

==== Adding Libraries to target ===

It is possible to use script [https://code.google.com/p/cmake-simple-build-environment/source/browse/trunk/scripts/helpers/AddDependenciesToTarget.cmake AddDependenciesToTarget.cmake]

<code language="cmake">
set(DEP_TARGET ${PROJECT_NAME})
set(DEP_TYPES_TO_ADD "Library" "Project")
include(SBE/helpers/AddDependenciesToTarget)
</code>

Or do it "low level" with `FIND_PACKAGE`

<code language="cmake">
include(SBE/helpers/DependenciesParser)
ParseDependencies("${DEPENDENCIES}" ownDependenciesIds)
include(${DEP_INFO_FILE})
# link all dependend libraries
foreach(dep ${ownDependenciesIds})
    set(depName ${${dep}_Name})
    find_package(${depName} REQUIRED CONFIG PATHS ${DEP_INSTALL_PATH}/config NO_DEFAULT_PATH)
    if(DEFINED ${depName}_INCLUDE_DIRS)
        include_directories(${${depName}_INCLUDE_DIRS})
    endif()                
    if(DEFINED ${depName}_LIBRARIES)
        # link all exported
        target_link_libraries(${PROJECT_NAME} ${${depName}_LIBRARIES})
    endif()                
endforeach()
</code>

== Unit testing ==

== Continuous Integration ==

== Coverity ==