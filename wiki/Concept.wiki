= Simple Build Environment concept =

The project provides CMake scripts usable in CMakeLists.txt of CPP package.

Simple Build Environment works with following CPP packages:
  * Library (e.g. [https://code.google.com/p/sbe-documentlibrary DocumentLibrary])
  * Executable (e.g. [https://code.google.com/p/sbe-helloworld HelloWorld])
  * Unit Test Framework (e.g. [https://code.google.com/p/sbe-cpputestlibrary CppUTest])
  * Project - group of Libraries/Executables (e.g. [https://code.google.com/p/sbe-documentationsystem DocumentationSystem])

The scripts support
  * Dependency management
  * Build 
  * Unit testing
  * Continuous Integration
  * Coverity

== Dependency management ==

Each package has file `Properties.cmake` in same directory as `CMakeLists.txt`. The file contains package description (e.g. [https://code.google.com/p/sbe-documentlibrary/source/browse/trunk/Properties.cmake Properties.cmake for DocumentLibrary]).
  * `NAME` - package name
  * `TYPE` - one of _Library, Executable, Unit Test Framework, Project_
  * `VERSION_MAJOR`, `VERSION_MINOR`, `VERSION_PATCH` - should be [http://semver.org semantic version]. 
  * `DESCRIPTION` - brief description
  * `MAINTAINER` - maintainer email address
  * `DEPENDENCIES` - contains description of each dependency used by package.
  

Each dependency has to have goals `install` and `uninstall`. During installation, dependency has to export its targets. The scripts [https://code.google.com/p/cmake-simple-build-environment/source/browse/trunk/scripts/AddInstallTarget.cmake AddInstallTarget.cmake], [https://code.google.com/p/cmake-simple-build-environment/source/browse/trunk/scripts/AddUninstallTarget.cmake AddUninstallTarget.cmake] do this work. It is enough to include them into CMakeLists.txt file (See [https://code.google.com/p/sbe-documentlibrary/source/browse/trunk/Properties.cmake DocumentLibrary Properties.cmake]) The export file is then used in `FIND_PACKAGE` during configuration of dependent package.

Package dependencies are described in variable `DEPENDENCIES`. Each dependency has to start with keyword `DEPENDENCY`. Each dependency can be described with:
  * `URL` - It is mandatory. 
    * It is repository location of dependency release.
  * `SCM` - It is optional. 
    * It is repository type. If no `SCM` keyword is given then default repository `svn` is used. Available types are:
      * svn
  * `EXTERNAL` - It is optional. 
    * Meaning of the flag is that dependency marked as external 
      * is not included in `package` target (see [http://code.google.com/p/cmake-simple-build-environment/source/browse/trunk/scripts/AddPackageTarget.cmake AddPackageTarget.cmake])
      * is not automatically updated to its latest releases 
    * When dependency is marked as `EXTERNAL` then all its dependencies are external too. External dependencies have black border and External Stereotype in dependency graph.
    [http://cmake-simple-build-environment.googlecode.com/svn/wiki/images/DependecyGraphExternal.png http://cmake-simple-build-environment.googlecode.com/svn/wiki/images/DependecyGraphExternalSmall.png]

Example:
<code language="cmake">
set(DEPENDENCIES 
DEPENDENCY 
    URL http://sbe-printerlibrary.googlecode.com/svn/tags/rel_1_0_0 
    SCM svn
    EXTERNAL 
DEPENDENCY 
    URL http://sbe-documentlibrary.googlecode.com/svn/tags/rel_1_0_0 
)
</code>

=== How it works ===

In your package CMakeLists.txt you have to include [https://code.google.com/p/cmake-simple-build-environment/source/browse/trunk/scripts/DeployDependencies.cmake DeployDependencies.cmake] (e.g. [https://code.google.com/p/sbe-documentlibrary/source/browse/trunk/CMakeLists.txt CMakeLists.txt for DocumentLibrary])

The script performs two steps
  * Exports sources (it uses [https://code.google.com/p/cmake-simple-build-environment/source/browse/trunk/scripts/ExportDependencies.cmake ExportDependencies.cmake])
  * Install sources (it uses [https://code.google.com/p/cmake-simple-build-environment/source/browse/trunk/scripts/InstallDependencies.cmake InstallDependencies.cmake])

During package configuration all dependencies are exported recursively and installed. 
Installation is necessary during package configuration, because include paths and libraries created by dependency are discovered by `FIND_PACKAGE`.

When dependencies are changed, their sources are deleted and uninstalled.

==== Export Sources ====

The script [https://code.google.com/p/cmake-simple-build-environment/source/browse/trunk/scripts/ExportDependencies.cmake ExportDependencies.cmake] uses `DEPENDENCIES` property defined in CMakeLists.txt to get all dependencies URL in repository.

It exports Properties.cmake recursively for each dependency and generates file `dependencies/info/info.cmake` in package. The file contains all properties from all dependencies.

Once all properties from all dependencies are exported, scripts performs
  # make dependency picture - it uses [http://plantuml.sourceforge.net/ plantuml]
  # check dependencies versions and report error if any - now exact version has to be used
    [http://cmake-simple-build-environment.googlecode.com/svn/wiki/images/DependecyGraphVersionMismatch.png http://cmake-simple-build-environment.googlecode.com/svn/wiki/images/DependecyGraphVersionMismatchSmall.png]
  # check dependencies installation order and report error if any
  # remove unused dependencies
  # exports dependencies sources

Once sources are exported file [http://cmake-simple-build-environment.googlecode.com/svn/wiki/snippets/info.cmake dependencies/info/info.cmake] is created and following variables are set by script [https://code.google.com/p/cmake-simple-build-environment/source/browse/trunk/scripts/ExportDependencies.cmake ExportDependencies.cmake]:
  * `DEP_SOURCES_PATH` - path where all dependencies are exported
  * `DEP_INFO_FILE` - full name of info.cmake file

There are information about each dependency used by package in `DEP_INFO_FILE`. The file can be included into CMakeLists.txt to access dependencies properties. Following variables are available:
  * `OverallDependencies` - it is list of all dependencies identifiers used by package
  * `DEP_INSTALLATION_ORDER` - it is list of dependencies identifiers in order to be installed. It is used by script [https://code.google.com/p/cmake-simple-build-environment/source/browse/trunk/scripts/InstallDependencies.cmake InstallDependencies.cmake]
  * `EXTERNAL_DEPENDENCIES` -  - it is list of dependencies identifiers that are marked as `EXTERNAL` in package
  * For each _dependency_ in `OverallDependencies` list following properties are defined
    * `${`_`dependency`_`}_Name` - name of dependency
    * `${`_`dependency`_`}_Type` - type of dependency
    * `${`_`dependency`_`}_Version` - string version in format major.minor.patch
    * `${`_`dependency`_`}_ScmPath` - URL to repository location
    * `${`_`dependency`_`}_ScmType` - repository type
    * `${`_`dependency`_`}_DependenciesDescription` - it is list same as `DEPENDENCIES` in dependency Properties.cmake file
    * `${`_`dependency`_`}_Dependencies` - it is list of dependencies identifiers
    * `${`_`dependency`_`}_IsExternal` - set to "yes" if dependency is marked as `EXTERNAL`, otherwise it is unset.

All this variables are later used in next configuration steps.

==== Install sources ====

The script [https://code.google.com/p/cmake-simple-build-environment/source/browse/trunk/scripts/InstallDependencies.cmake InstallDependencies.cmake] uses `dependencies/info/info.cmake` prepared by [https://code.google.com/p/cmake-simple-build-environment/source/browse/trunk/scripts/ExportDependencies.cmake ExportDependencies.cmake]. 

The scripts performs:
  # creates build directory `current_project_build_directory/dependencies/build/dependency_name` 
  # configure dependency in created build directory. `CMAKE_TOOLCHAIN_FILE` and `CMAKE_BUILD_TYPE` are propagated to dependency. 
  # install dependency via command `make install`. If coverity is requested, `cov_build` is performed. Once dependency is installed, dependent package can use `FIND_PACKAGE` to get information about dependency.

Once sources are installed following variables are set by script [https://code.google.com/p/cmake-simple-build-environment/source/browse/trunk/scripts/InstallDependencies.cmake InstallDependencies.cmake]:
  * `DEP_INSTALL_PATH` - path where all dependencies are installed

== Binary Targets ==

Once dependencies are installed, dependencies properties can be used to defined own package targets.

Simple Build Environment contains script [http://code.google.com/p/cmake-simple-build-environment/source/browse/trunk/scripts/AddBinaryTargets.cmake AddBinaryTargets.cmake] that do it in following way. 

It provides function
- sbeAddLibrary
- sbeAddExecutable
- sbeAddTestExecutable
- sbeAddObjects

<code language="cmake">
add_library(${PROJECT_NAME}SourceObjects OBJECT ${SOURCE_FILES})
)
</code>

See [http://code.google.com/p/sbe-documentlibrary/source/browse/trunk/CMakeLists.txt DocumentLibrary CMakeLists.txt].

If it is not suitable for you, you can write your own targets and use variables defined during dependencies deployment and Properties.cmake file of your package.

For example:

It is possible to use script [https://code.google.com/p/cmake-simple-build-environment/source/browse/trunk/scripts/helpers/AddDependenciesToTarget.cmake AddDependenciesToTarget.cmake]

<code language="cmake">
set(DEP_TARGET ${PROJECT_NAME})
set(DEP_TYPES_TO_ADD "Library" "Project")
include(SBE/helpers/AddDependenciesToTarget)
</code>

Or do it "low level" with `FIND_PACKAGE`

<code language="cmake">
# Parse dependencies description from own Properties.cmake.
# It has to be included before this code
include(SBE/helpers/DependenciesParser)
ParseDependencies("${DEPENDENCIES}" ownDependenciesIds)
# Get information about all dependencies
include(${DEP_INFO_FILE})
# link all dependent libraries
foreach(dep ${ownDependenciesIds})
    # Get name of dependency to find package by its name
    set(depName ${${dep}_Name})
    # Find dependency as package as usual in CMake
    find_package(${depName} REQUIRED CONFIG PATHS ${DEP_INSTALL_PATH}/config NO_DEFAULT_PATH)
    # Once package is found Include directories and package Libraries are defined. We can use them.
    if(DEFINED ${depName}_INCLUDE_DIRS)
        include_directories(${${depName}_INCLUDE_DIRS})
    endif()
    if(DEFINED ${depName}_LIBRARIES)
        # link all exported
        target_link_libraries(${PROJECT_NAME} ${${depName}_LIBRARIES})
    endif()                
endforeach()
</code>

== Unit Tests ==

Simple Build Environment uses [http://cpputest.github.io CppUTest]  as unit test framework. It is simply, easy to use and cross-compilable. See repository of project [http://code.google.com/p/sbe-cpputestlibrary/ CppUTestLibrary] how I integrate CppUTest into Simple Build Environment.

Simple Build Environment contains script [http://code.google.com/p/cmake-simple-build-environment/source/browse/trunk/scripts/AddTestTargets.cmake AddTestTargets.cmake] that creates test executable for package. It uses CppUTest as test framework.

The script has to be included after [http://code.google.com/p/cmake-simple-build-environment/source/browse/trunk/scripts/AddBinaryTargets.cmake AddBinaryTargets.cmake], because it links object library created by [http://code.google.com/p/cmake-simple-build-environment/source/browse/trunk/scripts/AddBinaryTargets.cmake AddBinaryTargets.cmake].

  # It creates main file for CppUTest framework from [http://code.google.com/p/cmake-simple-build-environment/source/browse/trunk/templates/CppUTestRunAllTests.cpp.in template]
  # It creates executable target with name `${PROJECT_NAME}Test` from object library, generated main file and test files.
  # It adds all libraries and unit test framework from package `DEPENDENCIES` to `${PROJECT_NAME}Test` target.
  # It adds `test` target that makes test executable and it runs tests (`make test`). In case of cross-compiling it doesn't run test executable but it prints message _Not possible to run test because of cross-compiling_.
  # It sets variable `INSTALL_TEST_EXECUTABLE` that is lately used in [http://code.google.com/p/cmake-simple-build-environment/source/browse/trunk/scripts/AddInstallTarget.cmake AddInstallTarget.cmake].

See [http://code.google.com/p/sbe-helloworld/source/browse/trunk/CMakeLists.txt HelloWorld CMakeLists.txt].

== Coverity ==

Simple Build Environment supports [http://www.coverity.com Coverity]. Simply include script [http://code.google.com/p/cmake-simple-build-environment/source/browse/trunk/scripts/AddCoverityTargets.cmake AddCoverityTargets.cmake] *before* script [http://code.google.com/p/cmake-simple-build-environment/source/browse/trunk/scripts/DeployDependencies.cmake DeployDependencies.cmake] to get coverity results.

  * It configures coverity in directory `${CMAKE_CURRENT_BINARY_DIR}/coverity`. Following compilers are supported:
    * GNU
    * Texas instruments
      * Even if you use CMake version 2.8.11 where TI compilers are suported, coverity for TI compiler will not work correctly, because at least coverity client in version 4.5.0 doesn't understand compiler's long name switches (e.g. --cpp_file). The switches are defined in CMake in file `CMAKE_INSTALLATION_DIRECTORY/Modules/Compiler/TI-\*.cmake`. In CMake version that I use, I manually change long name switches to its short names. 
  * Once Coverity is configured dependencies are build under `cov-build` command.
  * It creates target `coverity` that performs steps:
    * `cov-build make` this creates coverity data to analyze for package (data for dependencies are already created during dependencies installation)
    * `cov-analyze`
    * `cov-format-errors`

See [http://code.google.com/p/sbe-helloworld/source/browse/trunk/CMakeLists.txt HelloWorld CMakeLists.txt].

== Tagging sources ==

Will be added soon.

See [http://code.google.com/p/cmake-simple-build-environment/source/browse/trunk/scripts/AddTagTarget.cmake AddTagTarget.cmake].

== Packaging Sources ==

Will be added soon.

See [http://code.google.com/p/cmake-simple-build-environment/source/browse/trunk/scripts/AddPackageTarget.cmake AddPackageTarget.cmake].


== Continuous Integration ==

I use [http://jenkins-ci.org Jenkins] as continuous integration server.

==== Package integration ====

It is simple, basic scenario. It is necessary to check if package is compilable and unit test passes when more developers works on same package. It is done easily. A few plugin and tools are used in example
  * For unit testing
    * [https://wiki.jenkins-ci.org/display/JENKINS/Cobertura+Plugin Cobertura] - visualize test coverage. I use [https://software.sandia.gov/trac/fast/wiki/gcovr gcovr] to get coverage report compatible with Cobertura from GNU tools. Sources has to be compiled and linked with options `-fprofile-arcs -ftest-coverage -pg` (see [http://code.google.com/p/sbe-toolchains/source/browse/trunk/toolchains/GnuFlags.cmake GnuFlags.cmake])  
  * [https://wiki.jenkins-ci.org/display/JENKINS/Warnings+Plugin Warnings plugin] - get have information about warnings trend

See [http://cmake-simple-build-environment.googlecode.com/svn/wiki/images/JenkinsBasic.png Jenkins HelloWorld Job Configuration].

==== Multiple Configuration Package integration ====

It is sometime necessary to build package for various architectures. I use multi-configuration project for that.

There are names of toolchain files in row. 
There names of build types in column. 

There is one special combination [all,export]. This combination is executed first and it export package sources. Script `sbeExportDependencies` is used for that. Script is installed during Simple Build Environment installation from [http://code.google.com/p/cmake-simple-build-environment/source/browse/trunk/shellScripts/sbeExportDependencies.in template]. 
Once sources are exported, given combinations can be executed in parallel. When combination is configured, CMake doesn't exports sources due to given variable `-DDEP_SRC_DEPLOYMENT_PATH=`.

See [http://cmake-simple-build-environment.googlecode.com/svn/wiki/images/JenkinsMultiConfiguration.png Jenkins HelloWorld Multi-configuration Job Configuration].

==== Package integration with all its latest dependencies ====

Will be added soon.