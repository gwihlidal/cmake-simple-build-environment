cmake_minimum_required(VERSION 2.8)

#set(jira "{\"expand\":\"renderedFields,names,schema,transitions,operations,editmeta,changelog\",\"id\":\"153712\",\"self\":\"http://jira.frequentis.frq:8080/rest/api/2/issue/153712\",\"key\":\"PMC-1642\",\"fields\":{\"fixVersions\":[{\"self\":\"http://jira.frequentis.frq:8080/rest/api/2/version/15514\",\"id\":\"15514\",\"name\":\"MCS DROP 34 (28.1.2015)\",\"archived\":false,\"released\":true,\"releaseDate\":\"2015-01-28\"}],\"customfield_11200\":[\"com.atlassian.greenhopper.service.sprint.Sprint@593a91a2[rapidViewId=109,state=ACTIVE,name=MCS DROP 35 (18.2.2015),startDate=2015-01-30T22:12:43.571+01:00,endDate=2015-02-18T22:12:00.000+01:00,completeDate=<null>,sequence=20944,id=20944]\"],\"resolution\":{\"self\":\"http://jira.frequentis.frq:8080/rest/api/2/resolution/1\",\"id\":\"1\",\"description\":\"A fix for this issue is checked into the tree and tested.\",\"name\":\"Fixed\"},\"customfield_12410\":null,\"customfield_11202\":null,\"customfield_11203\":null,\"customfield_10500\":\"9223372036854775807\",\"customfield_12404\":null,\"customfield_12800\":null,\"customfield_12403\":null,\"customfield_12406\":null,\"customfield_12405\":null,\"customfield_12407\":null,\"customfield_10901\":null,\"customfield_12409\":null,\"customfield_10904\":null,\"customfield_10905\":null,\"customfield_10908\":null,\"lastViewed\":null,\"customfield_12000\":null,\"priority\":{\"self\":\"http://jira.frequentis.frq:8080/rest/api/2/priority/2\",\"iconUrl\":\"http://jira.frequentis.frq:8080/images/icons/priorities/critical.png\",\"name\":\"High\",\"id\":\"2\"},\"customfield_12402\":null,\"labels\":[\"SCRN\"],\"customfield_10103\":null,\"customfield_12401\":null,\"customfield_11700\":null,\"customfield_11702\":null,\"customfield_11701\":null,\"customfield_11704\":null,\"timeestimate\":null,\"aggregatetimeoriginalestimate\":null,\"versions\":[{\"self\":\"http://jira.frequentis.frq:8080/rest/api/2/version/15514\",\"id\":\"15514\",\"name\":\"MCS DROP 34 (28.1.2015)\",\"archived\":false,\"released\":true,\"releaseDate\":\"2015-01-28\"}],\"customfield_11703\":null,\"customfield_11705\":null,\"customfield_11708\":null,\"customfield_11707\":null,\"issuelinks\":[],\"assignee\":{\"self\":\"http://jira.frequentis.frq:8080/rest/api/2/user?username=sbellus\",\"name\":\"sbellus\",\"emailAddress\":\"Stefan.Bellus@frequentis.com\",\"avatarUrls\":{\"48x48\":\"http://jira.frequentis.frq:8080/secure/useravatar?ownerId=sbellus&avatarId=11903\",\"24x24\":\"http://jira.frequentis.frq:8080/secure/useravatar?size=small&ownerId=sbellus&avatarId=11903\",\"16x16\":\"http://jira.frequentis.frq:8080/secure/useravatar?size=xsmall&ownerId=sbellus&avatarId=11903\",\"32x32\":\"http://jira.frequentis.frq:8080/secure/useravatar?size=medium&ownerId=sbellus&avatarId=11903\"},\"displayName\":\"BELLUS Stefan\",\"active\":true},\"status\":{\"self\":\"http://jira.frequentis.frq:8080/rest/api/2/status/5\",\"description\":\"A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.\",\"iconUrl\":\"http://jira.frequentis.frq:8080/images/icons/statuses/resolved.png\",\"name\":\"Resolved\",\"id\":\"5\",\"statusCategory\":{\"self\":\"http://jira.frequentis.frq:8080/rest/api/2/statuscategory/3\",\"id\":3,\"key\":\"done\",\"colorName\":\"green\",\"name\":\"Complete\"}},\"components\":[{\"self\":\"http://jira.frequentis.frq:8080/rest/api/2/component/11607\",\"id\":\"11607\",\"name\":\"VCX CF Server\"}],\"customfield_12502\":null,\"customfield_12900\":null,\"aggregatetimeestimate\":null,\"creator\":{\"self\":\"http://jira.frequentis.frq:8080/rest/api/2/user?username=sbellus\",\"name\":\"sbellus\",\"emailAddress\":\"Stefan.Bellus@frequentis.com\",\"avatarUrls\":{\"48x48\":\"http://jira.frequentis.frq:8080/secure/useravatar?ownerId=sbellus&avatarId=11903\",\"24x24\":\"http://jira.frequentis.frq:8080/secure/useravatar?size=small&ownerId=sbellus&avatarId=11903\",\"16x16\":\"http://jira.frequentis.frq:8080/secure/useravatar?size=xsmall&ownerId=sbellus&avatarId=11903\",\"32x32\":\"http://jira.frequentis.frq:8080/secure/useravatar?size=medium&ownerId=sbellus&avatarId=11903\"},\"displayName\":\"BELLUS Stefan\",\"active\":true},\"subtasks\":[],\"reporter\":{\"self\":\"http://jira.frequentis.frq:8080/rest/api/2/user?username=sbellus\",\"name\":\"sbellus\",\"emailAddress\":\"Stefan.Bellus@frequentis.com\",\"avatarUrls\":{\"48x48\":\"http://jira.frequentis.frq:8080/secure/useravatar?ownerId=sbellus&avatarId=11903\",\"24x24\":\"http://jira.frequentis.frq:8080/secure/useravatar?size=small&ownerId=sbellus&avatarId=11903\",\"16x16\":\"http://jira.frequentis.frq:8080/secure/useravatar?size=xsmall&ownerId=sbellus&avatarId=11903\",\"32x32\":\"http://jira.frequentis.frq:8080/secure/useravatar?size=medium&ownerId=sbellus&avatarId=11903\"},\"displayName\":\"BELLUS Stefan\",\"active\":true},\"customfield_12100\":null,\"aggregateprogress\":{\"progress\":0,\"total\":0},\"customfield_12501\":null,\"customfield_12500\":null,\"customfield_11405\":null,\"customfield_11407\":null,\"customfield_11803\":null,\"customfield_11802\":null,\"customfield_11409\":null,\"customfield_11408\":null,\"customfield_11804\":null,\"progress\":{\"progress\":0,\"total\":0},\"votes\":{\"self\":\"http://jira.frequentis.frq:8080/rest/api/2/issue/PMC-1642/votes\",\"votes\":0,\"hasVoted\":false},\"worklog\":{\"startAt\":0,\"maxResults\":20,\"total\":0,\"worklogs\":[]},\"issuetype\":{\"self\":\"http://jira.frequentis.frq:8080/rest/api/2/issuetype/16\",\"id\":\"16\",\"description\":\"A potential or actual defect\",\"iconUrl\":\"http://jira.frequentis.frq:8080/images/icons/issuetypes/bug.png\",\"name\":\"Problem Report\",\"subtask\":false},\"timespent\":null,\"project\":{\"self\":\"http://jira.frequentis.frq:8080/rest/api/2/project/11503\",\"id\":\"11503\",\"key\":\"PMC\",\"name\":\"Maritime Communication Product\",\"avatarUrls\":{\"48x48\":\"http://jira.frequentis.frq:8080/secure/projectavatar?pid=11503&avatarId=10011\",\"24x24\":\"http://jira.frequentis.frq:8080/secure/projectavatar?size=small&pid=11503&avatarId=10011\",\"16x16\":\"http://jira.frequentis.frq:8080/secure/projectavatar?size=xsmall&pid=11503&avatarId=10011\",\"32x32\":\"http://jira.frequentis.frq:8080/secure/projectavatar?size=medium&pid=11503&avatarId=10011\"},\"projectCategory\":{\"self\":\"http://jira.frequentis.frq:8080/rest/api/2/projectCategory/10101\",\"id\":\"10101\",\"description\":\"Products [P...]\",\"name\":\"Products\"}},\"aggregatetimespent\":null,\"resolutiondate\":\"2015-01-30T09:31:19.047+0100\",\"workratio\":-1,\"watches\":{\"self\":\"http://jira.frequentis.frq:8080/rest/api/2/issue/PMC-1642/watchers\",\"watchCount\":1,\"isWatching\":false},\"created\":\"2015-01-27T08:14:59.257+0100\",\"customfield_12600\":null,\"customfield_12203\":\"0.0\",\"customfield_11501\":null,\"customfield_11902\":null,\"updated\":\"2015-01-30T09:31:19.093+0100\",\"timeoriginalestimate\":null,\"description\":\"When Channel Frequencies share Tx, it is possible that one is located at Channel Frequency Server 1 and second on Channel Frequency Server 2.\r\nIn that case shared Tx is connected only at one Channel Frequency Server, all Channel Frequencies located at other one are not selectable.\r\n\r\n*Solution:*\r\nWhen Channel Frequency Server receive release on Shared Tx call with cause Limit Exceed, it will release also call to Rx. It will retry the call to Rx after 22 seconds to give chance to another Channel Frequency Server to get the released Rx.\r\n\r\n*Warning:*\r\nDue to lack of time we will implement the solution only for case when Channel Frequencies share only *one shared Tx*. \r\nAll shared Tx scenarios will be solved in issue PMC-1377.\r\n\",\"customfield_13000\":\"0|i0ma9v:\",\"customfield_11500\":null,\"timetracking\":{},\"customfield_11215\":\" X \",\"customfield_12700\":null,\"customfield_11216\":\"MAPE07\",\"security\":{\"self\":\"http://jira.frequentis.frq:8080/rest/api/2/securitylevel/10200\",\"id\":\"10200\",\"description\":\"\",\"name\":\"Intern\"},\"customfield_11217\":\"PMC-1642 is caused by: NO REQUIREMENTS LINKED Requirements changed:\",\"attachment\":[],\"summary\":\"It is not possible to switch Channel Frequency with Shared Tx \\\\\"to\\\\\" [selec] {in} case of Ge-redundancy \",\"customfield_10000\":null,\"customfield_11210\":null,\"customfield_11211\":null,\"customfield_12301\":\"Resolved\",\"customfield_11212\":null,\"customfield_12300\":\"Is not delegated\",\"customfield_11213\":{\"self\":\"http://jira.frequentis.frq:8080/rest/api/2/customFieldOption/10738\",\"value\":\"Marginal\",\"id\":\"10738\"},\"customfield_11204\":null,\"customfield_11205\":null,\"customfield_11600\":null,\"environment\":null,\"customfield_11208\":null,\"duedate\":null,\"customfield_10916\":null,\"comment\":{\"startAt\":0,\"maxResults\":0,\"total\":0,\"comments\":[]}}}")
#set(jira "\"employees\":[{\"firstName\":\"John\", \"lastName\":\"Doe\"},{\"firstName\":\"Anna\", \"lastName\":\"Smith\"},{\"firstName\":\"Peter\",\"lastName\":\"Jones\"}]")

if (DEFINED JSonParserGuard)
    return()
endif()

set(JSonParserGuard yes)

macro(sbeParseJson prefix jsonString)
    cmake_policy(PUSH)

    set(json_string ${jsonString})    
    
    string(LENGTH ${json_string} json_jsonLen)
    set(json_index 0)
    set(json_AllVariables ${prefix})

    _sbeParse(${prefix})
    
    unset(json_index)
    unset(json_AllVariables)
    unset(json_jsonLen)
    unset(json_string)
    unset(json_value)
    unset(json_inValue)    
    unset(json_name)
    unset(json_inName)
    unset(json_newPrefix)
    unset(json_nextChar)
    unset(json_nextIndex)
    unset(json_reservedWord)
    unset(json_arrayIndex)
    unset(json_char)
    unset(json_end)
    cmake_policy(POP)
endmacro()

macro(sbeClearJson prefix)
    foreach(var ${${prefix}})
        unset(${var})
    endforeach()
    
    unset(${prefix})
endmacro()

macro(sbePrintJson prefix)
    foreach(var ${${prefix}})
        message("${var} = ${${var}}")
    endforeach()
    
    unset(${prefix})
endmacro()

macro(_sbeParse prefix)

    while(${json_index} LESS ${json_jsonLen})
        string(SUBSTRING ${json_string} ${json_index} 1 json_char)
        
        if("\"" STREQUAL "${json_char}")    
            _sbeParseNameValue(${prefix})
        elseif("{" STREQUAL "${json_char}")
            math(EXPR json_index "${json_index} + 1")
            _sbeParseObject(${prefix})
        elseif("[" STREQUAL "${json_char}")
            math(EXPR json_index "${json_index} + 1")
            _sbeParseArray(${prefix})
        endif()

        if(${json_index} LESS ${json_jsonLen})
            string(SUBSTRING ${json_string} ${json_index} 1 json_char)
        else()
            break()
        endif()

        if ("}" STREQUAL "${json_char}" OR "]" STREQUAL "${json_char}")
            break()
        endif()
        
        math(EXPR json_index "${json_index} + 1")
    endwhile()    
endmacro()

macro(_sbeParseNameValue prefix)
    set(json_name "")
    set(json_inName no)

    while(${json_index} LESS ${json_jsonLen})
        string(SUBSTRING ${json_string} ${json_index} 1 json_char)
        
        # check if name ends
        if("\"" STREQUAL "${json_char}" AND json_inName)
            set(json_inName no)
            math(EXPR json_index "${json_index} + 1")
            string(SUBSTRING ${json_string} ${json_index} 1 json_char)
            set(json_newPrefix ${prefix}.${json_name})
            set(json_name "")
            
            if(":" STREQUAL "${json_char}")
                math(EXPR json_nextIndex "${json_index} + 1")
                string(SUBSTRING ${json_string} ${json_nextIndex} 1 json_nextChar)

                if("\"" STREQUAL "${json_nextChar}")    
                    _sbeParseValue(${json_newPrefix})
                    break()
                elseif("{" STREQUAL "${json_nextChar}")
                    math(EXPR json_index "${json_index} + 2")
                    _sbeParseObject(${json_newPrefix})
                    break()
                elseif("[" STREQUAL "${json_nextChar}")
                    math(EXPR json_index "${json_index} + 2")
                    _sbeParseArray(${json_newPrefix})
                    break()
                else()
                    # reserved word starts
                    math(EXPR json_index "${json_index} + 1")
                    set(json_reservedWord "")
                    set(json_end no)
                    while(json_index LESS ${json_jsonLen} AND NOT json_end)
                        string(SUBSTRING ${json_string} ${json_index} 1 json_char)
                        
                        if("," STREQUAL "${json_char}" OR "}" STREQUAL "${json_char}" OR "]" STREQUAL "${json_char}")
                            set(json_end yes)
                        else()
                            set(json_reservedWord "${json_reservedWord}${json_char}")
                            math(EXPR json_index "${json_index} + 1")
                        endif()
                    endwhile()

                    list(APPEND ${json_AllVariables} ${json_newPrefix})
                    set(${json_newPrefix} ${json_reservedWord})
                    break()
                endif()
            else()
                # name without value
                list(APPEND ${json_AllVariables} ${json_newPrefix})
                set(${json_newPrefix} "")
                break()            
            endif()           
        endif()

        if(json_inName)
            # escapes remove
            if("\\" STREQUAL "${json_char}")
                math(EXPR json_index "${json_index} + 1")
                string(SUBSTRING ${json_string} ${json_index} 1 json_char)
            endif()
        
            set(json_name "${json_name}${json_char}")
        endif()
        
        # check if name starts
        if("\"" STREQUAL "${json_char}" AND NOT json_inName)
            set(json_inName yes)
        endif()
       
        math(EXPR json_index "${json_index} + 1")
    endwhile()    
endmacro()

macro(_sbeParseValue prefix)
    cmake_policy(SET CMP0054 NEW) # turn off implicit expansions in if statement
    
    set(json_value "")
    set(json_inValue no)
    
    while(${json_index} LESS ${json_jsonLen})
        string(SUBSTRING ${json_string} ${json_index} 1 json_char)
        
        # check if json_value ends
        if("\"" STREQUAL "${json_char}" AND json_inValue)
            set(json_inValue no)
            
            set(${prefix} ${json_value})
            list(APPEND ${json_AllVariables} ${prefix})
            math(EXPR json_index "${json_index} + 1")
            break()
        endif()
                
        if(json_inValue)
            # escapes remove
            if("\\" STREQUAL "${json_char}")
                math(EXPR json_index "${json_index} + 1")
                string(SUBSTRING ${json_string} ${json_index} 1 json_char)
            endif()      
              
            set(json_value "${json_value}${json_char}")
        endif()
        
        # check if value starts
        if("\"" STREQUAL "${json_char}" AND NOT json_inValue)
            set(json_inValue yes)
        endif()
        
        math(EXPR json_index "${json_index} + 1")
    endwhile()
    
endmacro()

macro(_sbeParseObject prefix)
    _sbeParse(${prefix})
    math(EXPR json_index "${json_index} + 1")
endmacro()

macro(_sbeParseArray prefix)
    set(json_arrayIndex 0)

    set(${prefix} "")
    list(APPEND ${json_AllVariables} ${prefix})

    while(${json_index} LESS ${json_jsonLen})
        string(SUBSTRING ${json_string} ${json_index} 1 json_char)
        
        if("\"" STREQUAL "${json_char}")
            # simple value
            list(APPEND ${prefix} ${json_arrayIndex})
            _sbeParseValue(${prefix}[${json_arrayIndex}])
        elseif("{" STREQUAL "${json_char}")
            # object
            math(EXPR json_index "${json_index} + 1")
            list(APPEND ${prefix} ${json_arrayIndex})
            _sbeParseObject(${prefix}[${json_arrayIndex}])
        endif()
        
        string(SUBSTRING ${json_string} ${json_index} 1 json_char)
        
        if("]" STREQUAL "${json_char}")
            math(EXPR json_index "${json_index} + 1")
            break()
        elseif("," STREQUAL "${json_char}")
            math(EXPR json_arrayIndex "${json_arrayIndex} + 1")            
        endif()

        math(EXPR json_index "${json_index} + 1")
    endwhile()    

endmacro()


#sbeParseJson(tt "${jira}")
#sbePrintJson(tt)